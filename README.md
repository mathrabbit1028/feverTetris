# feverTetris

## File Description
이 레포지토리는 2023-2 SSHS 고급프로그래밍 수행평가 "C언어를 활용한 테트리스의 제작"에서 만들어진 변형 테트리스 "**feverTetris**"의 개발 과정을 포함한 코드입니다.

- 01_fever_tetris : 기본 테트리스 구현 코드
- 02_key_shuffle : key bind shuffle이 포함된 코드
- 03_board_rotation : board rotation이 포함된 코드
- 04_small_block : small block이 포함된 코드
- 05_millisecond : 시간 단위가 1초였던 이슈를 해결한 코드
- 06_fever_time.cpp : 피버 타임을 추가하며 다양한 버그를 해결한 코드

06_fever_time.cpp를 제외한 다른 코드에는 버그가 존재할 수 있음에 유의하기 바랍니다.

## How to Play
올라가는 피버 게이지에 의해 방해 요소가 발동합니다! 최대한 오래 생존하여 높은 점수를 얻으세요!

1. 피버 게이지 : 피버 게이지는 1/30초마다 위로 남은 여유 줄 수에 5를 더한 값만큼 증가합니다. 이 값이 기준치를 넘어가게 되면 피버 타임이 발동됩니다.
2. 피버 타임 : 피버 타임에는 점수가 두 배이지만 세 종류의 방해 요소 중 하나가 발동합니다.
3. 방해 요소 1 : 블록 대신 보드가 회전합니다! 전체 스크린에 대한 블록은 모양이 변하지 않지만 전체 스크린에 대해 보드가 회전함으로써 블록을 회전합니다.
4. 방해 요소 2 : 키 중 두 개라 랜덤하게 바뀌거나 하나의 키의 사용이 제한됩니다.
5. 방해 요소 3 : 고스트가 사라지고, 블록이 사각형 모양에서 점으로 바뀝니다.

키에 따른 블록의 이동은 다음과 같습니다:
| 동작 | 왼쪽 이동  | 오른쪽 이동  | 소프트 드랍 | 하드 드랍 | 시계 방향 회전 | 반시계 방향 회전 | 홀드  |
|----|--------|---------|--------|-------|----------|-----------|-----|
| 키  | 왼쪽 화살표 | 오른쪽 화살표 | 아래 화살표 | 스페이스  | X 키      | Z 키       | C 키 |

## Implementation Details

1. 더블 버퍼링
- Flicking 현상의 발생을 방지하기 위해 더블 버퍼링을 사용했습니다. 더블 버퍼링 설정은 ```namespace doubleConsole```에서 이루어집니다. ```doubleConsole::console```을 통해 콘솔을 불러올 수 있습니다.
2. 랜더링
- 모든 랜더링은 ```printboard()``` 함수에서 이루어집니다. 또한 랜더링 코드의 간결화를 위해 다음 함수들이 구현되었습니다:
  - ```_cout(int, int, char)```: 기본 출력 방식은 하나의 문자를 원하는 위치에 출력하는 것입니다. 그 과정을 함수로 묶어 구현했습니다.
  - ```_wcout(int, int, wchar_t)```: 유니코드 출력을 위해서는 유니코드 문자 전용 타입인 ```wchar_t```를 사용해야 합니다. 유니코드를 출력하는 함수입니다.
  - ```printstr(int, int, char*)```: 시작 위치와 문자열을 입력하면 가로로 문자열을 출력하는 함수입니다.
  - ```printint(int, int, long long)```: 시작 위치와 정수를 입력하면 정수형 변수를 출력하는 함수입니다. 오버플로우 방지를 위해 ```long long``` 타입으로 설정했습니다.
  - ```printline(int, int, int, int, char)```: 줄의 양 끝 위치를 입력하면 가로줄 또는 세로줄일 때 모든 칸에 입력받은 문자를 출력합니다.
  - ```printrect(int, int, int, int)```: 주어진 두 꼭짓점을 양 끝으로 하는 사각형을 출력합니다. ```printline```으로 구현되었습니다.
- 다음 블록과 홀드 블록의 표시를 위해 ```const int ch[][][]```가 만들어졌습니다. 다음 블록과 홀드 블록을 표시할 때 블록이 있는 칸은 1, 없는 칸은 0입니다.
- next를 표시할 때 다음 다섯 블록을 얻어오기 위해 덱 두 개를 사용했습니다. 하나의 덱에서 앞에서부터 빼 다른 덱이 저장하고, 다시 먼저 뺀 블록부터 원래의 덱에 넣는 방식입니다.
- 오른쪽 박스의 제일 윗 줄에는 현재 방해 요소를 나타냅니다. 키 변경, 블록 회전, 텍스쳐 변경 순으로 출력하는 코드가 표시되어 있습니다.

4. 블록 시각화와 SRS 시스템
5. 메인 로직
6. 보드 업데이트
7. 시간 계산
8. 피버 타임 로직
9. 보드 회전 로직
10. 키 변경 로직
11. 텍스쳐 변경 로직


